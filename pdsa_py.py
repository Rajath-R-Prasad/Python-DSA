# -*- coding: utf-8 -*-
"""PDSA.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1is7wvWNb7RKt815HNS0Y_EXyM52Cr__T
"""

#timer function
import time
class Timer:
  def __init__(self):
    self.start_time=None
    self.elapsed_time=None
  def start(self):
    if self.start_time is not None:
      raise TimerError("timer is running . use .stop()")
    self.start_time=time.perf_counter()

  def stop(self):
    if self.start_time is None:
      raise TimerError("Timer has not started,use .start()")
    self.elapsed_time=time.perf_counter()-self.start_time
    self.start_time=None

  def elapsed(self):
    if self.elapsed_time is None:
      raise TimerError("timer has not yet started. use .start()")
    return(self.elapsed_time)
  def __str__(self):
    return (str(self.elapsed_time))

"""#BINARY SEARCH

"""

#binary search implementation
def binarysearch(v,l):
  if l==[]:
    return False
  m=len(l)//2
  if v==l[m]:
    return True
  elif v<l[m]:
    return binarysearch(v,l[:m])
  else:
    return binarysearch(v,l[m+1:])

t=Timer()
t.start()
print(binarysearch(890,[1,4,9,11,14,15,17,18,23,24,25,27,28,29,31,32,34,36,37,40,56,78,79,80,81,82,85,86,89,90,92,100,112,344,456,678,689,711,723,724,768,890]))
t.stop()
print(t)

"""# SORTING ALGORITHMS

- Selection Sort
"""

#SELECTION SORT
def selectionsort(l):
  n=len(l)
  if n<1:
    return l
  for i in range(n):
    mpos=i
    for j in range(i+1,n):
      if l[j]<l[mpos]:
        mpos=j
    (l[i],l[mpos])=(l[mpos],l[i])
  return l

t=Timer()
t.start()
print(selectionsort([34,67,12,35,56,90,44,567,23,89,32,67,46,222,33,987,56,788,445,2,335]))
t.stop()
print(t)

"""- Insertion Sort"""

def insertionsort(l):
  n=len(l)
  if n<1:
    return l
  for i in range(n):
    j=i
    while(j>0 and l[j]<l[j-1]):
      (l[j],l[j-1])=(l[j-1],l[j])
      j-=1
  return l

t=Timer()
t.start()
print(insertionsort([34,67,12,35,56,90,44,567,23,89,32,67,46,222,33,987,56,788,445,2,335]))
t.stop()
print(t)

"""# Linked-lists

"""

#Implementation of Linked-lists
class Node:
  def __init__(self,data=None,next=None):
    self.data=data
    self.next=next

class LinkedList():
  def __init__(self):
    self.head=None

  def print(self):
      if self.head is None:
          print("Linked list is empty")
          return
      itr = self.head
      llstr = ''
      while itr:
          llstr += str(itr.data)+' --> ' if itr.next else str(itr.data)
          itr = itr.next
      print(llstr)

  def get_length(self):
    count=0
    itr=self.head
    while itr:
      count+=1
      itr=itr.next
    return count

  def insert_at_beg(self,data):
    node=Node(data,self.head)
    self.head=node

  def insert_at_end(self,data):
    if self.head is None:
      self.head=Node(data,None)
      return
    itr=self.head
    while itr.next:
      itr=itr.next
    itr.next=Node(data,None)

  def insert_at(self,index,data):
    if index<0 or index>self.get_length():
      raise Exception ("Invalid Index")
    if index==0:
      self.insert_at_beg(data)
      return

    count=0
    itr=self.head
    while itr:

      if count==index-1:
        node=Node(data,itr.next)
        itr.next=node
        break
      itr=itr.next
      count+=1
  def remove_at(self,index):
    if index<0 or index>self.get_length():
      print("invalid syntax")

    if index==0:
      self.head=self.head.next
      return

    count=0
    itr=self.head
    while itr:
      if count==index-1:
          itr.next=itr.next.next
          break
      itr=itr.next
      count+=1

  def insert_values(self,data_list):
    self.head=None
    for data in data_list:
      self.insert_at_end(data)

ll=LinkedList()
ll.insert_at_beg(3)
ll.insert_at_end(4)
ll.insert_at_end(2)
ll.insert_at_end(6)
ll.insert_at(2,7)
ll.insert_at(0,5)
ll.insert_at(4,"hello")
ll.insert_at(1,"hi")
ll.insert_at(3,8)
ll.insert_at(5,78)
ll.print()
ll.get_length()

ll1=LinkedList()
ll1.insert_values([3,5,6,8,9])
ll1.insert_at_beg(7)
ll1.insert_at(5,1)
ll1.insert_at(3,89)
ll1.insert_at(4,"linkedlist")
ll1.print()
ll1.get_length()

"""# Graph and Trees"""

#queue implementation
class queue():
  def __init__(self):
    self.queue=[]
  def isempty(self):
    return self.queue==[]
  def enqueue(self,v):
    self.queue.append(v)
  def dequeue(self):
    v=None
    if not self.isempty():
      v=self.queue[0]
      self.queue=self.queue[1:]
    return v
  def __str__(self):
    return (self.queue==[])

#stack implementation
class stack:
  def ___init__(self):
    self.stack=[]
    def issempty(self):
      return (self.stack==[])
    def push(self,v):
      self.stack.append(v)
    def pop(self):
      v=None
      if not self.isempty():
        v=self.stack.pop()
      return v

#Adjacency List Implementation

def adjlist(V,E):
  size=len(V)
  Alist={}
  for i in range(size):
    Alist[i]=[]
  for (i,j) in E:
    Alist[i].append(j)
  return (Alist)

"""- BFS Implementation"""

#BFS implementation
def BFS(Alist,v):
  (level,parent)=({},{})
  for each_vertex in Alist.keys():
    parent[each_vertex]=-1
    level[each_vertex]=-1
  q=queue()
  level[v]=0
  q.enqueue(v)
  while not q.isempty():
    curr_vertex=q.dequeue()
    for adj_vertex in Alist[curr_vertex]:
      if level[adj_vertex]==-1:
        parent[adj_vertex]=curr_vertex
        level[adj_vertex]=level[curr_vertex]+1
  return (level,parent)

AList ={0: [1, 2], 1: [3, 4], 2: [4, 3], 3: [4], 4: []}
print(BFS(AList,0))